#!/usr/bin/env php
<?php

declare(strict_types=1);

// -----------------------------------------------------------------------------
// CLI entrypoint for CalendarScheduler (V2)
// -----------------------------------------------------------------------------

use CalendarScheduler\Manifest\ManifestWriter;
use CalendarScheduler\Diff\Diff;
use CalendarScheduler\Intent\IntentNormalizer;
use CalendarScheduler\Intent\NormalizationContext;
use CalendarScheduler\Platform\FPPSemantics;
use CalendarScheduler\Platform\HolidayResolver;
use CalendarScheduler\Adapter\Google\GoogleCalendarAdapter;
use CalendarScheduler\Adapter\FppScheduleRawEventAdapter;
use CalendarScheduler\Adapter\CalendarTranslator;
use CalendarScheduler\Adapter\CalendarSnapshot;

// -----------------------------------------------------------------------------
// Bootstrap
// -----------------------------------------------------------------------------

require_once __DIR__ . '/../bootstrap.php';

// -----------------------------------------------------------------------------
// Defaults
// -----------------------------------------------------------------------------

$DEFAULT_SCHEDULE_PATH =
    '/home/fpp/media/config/schedule.json';

$DEFAULT_MANIFEST_PATH =
    '/home/fpp/media/config/calendar-scheduler/manifest.json';

$DEFAULT_CALENDAR_SNAPSHOT_PATH =
    '/home/fpp/media/config/calendar-scheduler/calendar/calendar-snapshot.json';

// Optional: if your Google adapter reads from an intents file instead of snapshot,
// override via --calendar or env var in the future.

// -----------------------------------------------------------------------------
// Argument parsing
// -----------------------------------------------------------------------------

$opts = getopt('', [
    'dry-run',
    'schedule:',
    'manifest:',
    'format:',
    'quiet',
    'refresh-calendar',
]);

$dryRun = array_key_exists('dry-run', $opts);
$quiet  = array_key_exists('quiet', $opts);
$refreshCalendar = array_key_exists('refresh-calendar', $opts);

$schedulePath = $opts['schedule'] ?? $DEFAULT_SCHEDULE_PATH;
$manifestPath = $opts['manifest'] ?? $DEFAULT_MANIFEST_PATH;
$format       = $opts['format']   ?? 'text';

if (!in_array($format, ['text', 'json'], true)) {
    fwrite(STDERR, "ERROR: --format must be 'text' or 'json'\n");
    exit(64);
}

// -----------------------------------------------------------------------------
// Dependency construction
// -----------------------------------------------------------------------------

// -------------------------------------------------------------------------
// Export FPP environment via web context (authoritative, always fresh)
// -------------------------------------------------------------------------


$envPath = '/home/fpp/media/config/calendar-scheduler/runtime/fpp-env.json';

$readEnvEpoch = static function (string $path): int {
    if (!file_exists($path)) {
        return 0;
    }
    $data = json_decode(file_get_contents($path), true);
    if (!is_array($data)) {
        return 0;
    }
    $epoch = $data['generatedAtEpoch'] ?? 0;
    return is_int($epoch) ? $epoch : (int) $epoch;
};

$beforeEpoch = $readEnvEpoch($envPath);

$envUrl = getenv('GCS_FPP_ENV_URL');
if ($envUrl === false || trim($envUrl) === '') {
    $envUrl = 'http://127.0.0.1/plugin.php?plugin=GoogleCalendarScheduler&page=fpp-env-export.php&nopage=1';
}

$cmd = 'curl --silent --show-error --fail --max-time 5 '
     . '--output /dev/null '
     . escapeshellarg($envUrl);
exec($cmd, $out, $rc);

if ($rc !== 0) {
    throw new RuntimeException('Failed to invoke FPP environment exporter via web');
}

if (!file_exists($envPath)) {
    throw new RuntimeException('fpp-env.json was not written by web exporter');
}

$env = json_decode(file_get_contents($envPath), true);
if (!is_array($env)) {
    throw new RuntimeException('fpp-env.json is not valid JSON');
}

if (($env['ok'] ?? false) !== true) {
    $errors = $env['errors'] ?? [];
    $msg = is_array($errors) ? implode('; ', $errors) : (string) $errors;
    throw new RuntimeException('fpp-env.json export failed: ' . $msg);
}

$afterEpoch = $env['generatedAtEpoch'] ?? 0;
$afterEpoch = is_int($afterEpoch) ? $afterEpoch : (int) $afterEpoch;

if ($afterEpoch <= $beforeEpoch) {
    throw new RuntimeException('fpp-env.json was not refreshed (generatedAtEpoch did not advance)');
}

try {
    // -------------------------------------------------------------------------
    // Refresh calendar snapshot if requested
    // -------------------------------------------------------------------------
    if ($refreshCalendar) {
        // Use the correct constructor for CalendarTranslator (with IcsParser and snapshot path)
        $icsParser = new \CalendarScheduler\Adapter\IcsParser();
        $translator = new CalendarTranslator($icsParser, $DEFAULT_CALENDAR_SNAPSHOT_PATH);
        $snapshot = new CalendarSnapshot($translator);

        try {
            $events = $snapshot->refreshFromIcs();
            $snapshot->write($events);
            fwrite(STDERR, "[INFO] Calendar snapshot refreshed\n");
        } catch (\Throwable $e) {
            throw new RuntimeException('Failed to refresh calendar snapshot: ' . $e->getMessage());
        }
    }

    // -------------------------------------------------------------------------
    // Normalization context
    // -------------------------------------------------------------------------


    $tzName = $env['timezone']
        ?? $env['rawLocale']['timezone']
        ?? 'UTC';

    $context = new NormalizationContext(
        new DateTimeZone($tzName),
        new FPPSemantics(),
        new HolidayResolver($env['rawLocale']['holidays'])
    );

    $normalizer = new IntentNormalizer();

    // -------------------------------------------------------------------------
    // Load existing manifest (if any)
    // -------------------------------------------------------------------------

    $currentManifest = ['events' => []];
    if (file_exists($manifestPath)) {
        $currentManifest = json_decode(
            file_get_contents($manifestPath),
            true,
            512,
            JSON_THROW_ON_ERROR
        );
    }


    // -------------------------------------------------------------------------
    // Calendar → adapter → RawEvent → Intent (desired state)
    // -------------------------------------------------------------------------

    $calendarAdapter = new GoogleCalendarAdapter();

    $calendarIntents = [];
    $calendarAuthority = [];
    foreach ($calendarAdapter->read($context, $DEFAULT_CALENDAR_SNAPSHOT_PATH) as $raw) {
        fprintf(
            STDERR,
            "[DEBUG] RawEvent source=%s target=%s updatedAt=%d\n",
            $raw->source,
            $raw->target,
            $raw->sourceUpdatedAt
        );
        $intent = $normalizer->fromRaw($raw, $context);
        $hash = $intent->identityHash;
        $calendarIntents[$hash] = $intent;
        $calendarAuthority[$hash] = (int)($raw->sourceUpdatedAt ?? 0);
    }

    // -------------------------------------------------------------------------
    // FPP → adapter → RawEvent → Intent (current state contributor)
    // -------------------------------------------------------------------------
    
    $fppAdapter = new FppScheduleRawEventAdapter();

    foreach ($fppAdapter->read($context, $schedulePath) as $raw) {
        fprintf(
            STDERR,
            "[DEBUG] RawEvent source=%s target=%s updatedAt=%d\n",
            $raw->source,
            $raw->target,
            $raw->sourceUpdatedAt
        );
        $intent = $normalizer->fromRaw($raw, $context);
        $hash = $intent->identityHash;
        $rawTs = (int)($raw->sourceUpdatedAt ?? 0);

        if (!isset($calendarIntents[$hash])) {
            $calendarIntents[$hash] = $intent;
            $calendarAuthority[$hash] = $rawTs;
        } else {
            // Phase 2.1 authority: later timestamp wins
            $existingTs = (int)($calendarAuthority[$hash] ?? 0);
            if ($rawTs > $existingTs) {
                $calendarIntents[$hash] = $intent;
                $calendarAuthority[$hash] = $rawTs;
            }
        }
    }

    // -------------------------------------------------------------------------
    // Build Next Manifest
    // -------------------------------------------------------------------------

    $writer = new ManifestWriter($manifestPath);
    $nextManifest = $writer->buildManifestFromIntents($calendarIntents);

    // -------------------------------------------------------------------------
    // Diff (manifest → manifest)
    // -------------------------------------------------------------------------

    $diff = new Diff();
    $diffPlan = $diff->diff(
        $nextManifest,
        $currentManifest
    );

    // -------------------------------------------------------------------------
    // Write manifest
    // -------------------------------------------------------------------------

    if (!$dryRun) {
        $writer->applyDiff(
            $currentManifest,
            $diffPlan,
            $calendarIntents
        );
    }


} catch (\InvalidArgumentException $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(1);

} catch (\RuntimeException $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(1);

} catch (Throwable $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(2);
}

// -----------------------------------------------------------------------------
// Output
// -----------------------------------------------------------------------------

$countCreate = $diffPlan->createCount();
$countUpdate = $diffPlan->updateCount();
$countDelete = $diffPlan->deleteCount();

if ($format === 'json') {
    echo json_encode([
        'noop'    => $countCreate === 0 && $countUpdate === 0 && $countDelete === 0,
        'created' => $countCreate,
        'updated' => $countUpdate,
        'deleted' => $countDelete,
        'dry_run' => $dryRun,
    ], JSON_PRETTY_PRINT) . "\n";
    exit(0);
}

// text output
if ($quiet) {
    exit(0);
}

if ($countCreate === 0 && $countUpdate === 0 && $countDelete === 0) {
    echo "Scheduler run complete.\n";
    echo "No changes required.\n";
    exit(0);
}

if ($dryRun) {
    echo "Dry run complete.\n";
    echo "Would create: {$countCreate}\n";
    echo "Would update: {$countUpdate}\n";
    echo "Would delete: {$countDelete}\n";
    exit(0);
}

echo "Scheduler run complete.\n";
echo "Created: {$countCreate}\n";
echo "Updated: {$countUpdate}\n";
echo "Deleted: {$countDelete}\n";
exit(0);
