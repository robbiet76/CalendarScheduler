#!/usr/bin/env php
<?php

declare(strict_types=1);

// -----------------------------------------------------------------------------
// CLI entrypoint for CalendarScheduler (V2)
// -----------------------------------------------------------------------------

use CalendarScheduler\Planner\ManifestPlanner;
use CalendarScheduler\Diff\Diff;
use CalendarScheduler\Apply\ApplyRunner;
use CalendarScheduler\Apply\ManifestWriter;
use CalendarScheduler\Diff\Reconciler;
use CalendarScheduler\Diff\ReconciliationAction;
use CalendarScheduler\Intent\IntentNormalizer;
use CalendarScheduler\Intent\NormalizationContext;
use CalendarScheduler\Platform\FPPSemantics;
use CalendarScheduler\Platform\HolidayResolver;
use CalendarScheduler\Platform\IcsParser;
use CalendarScheduler\Adapter\Google\GoogleCalendarAdapter;
use CalendarScheduler\Adapter\FppScheduleAdapter;
use CalendarScheduler\Adapter\CalendarTranslator;
use CalendarScheduler\Adapter\CalendarSnapshot;
use CalendarScheduler\Apply\ApplyOptions;
use CalendarScheduler\Apply\ApplyMode;
use CalendarScheduler\Apply\WritableTargets;

// -----------------------------------------------------------------------------
// Bootstrap
// -----------------------------------------------------------------------------

require_once __DIR__ . '/../bootstrap.php';

// -----------------------------------------------------------------------------
// Defaults
// -----------------------------------------------------------------------------

$DEFAULT_SCHEDULE_PATH =
    '/home/fpp/media/config/schedule.json';

$DEFAULT_MANIFEST_PATH =
    '/home/fpp/media/config/calendar-scheduler/manifest.json';

$DEFAULT_CALENDAR_SNAPSHOT_PATH =
    '/home/fpp/media/config/calendar-scheduler/calendar/calendar-snapshot.json';

// Optional: if your Google adapter reads from an intents file instead of snapshot,
// override via --calendar or env var in the future.

// -----------------------------------------------------------------------------
// Argument parsing
// -----------------------------------------------------------------------------

$opts = getopt('', [
    'dry-run',
    'schedule:',
    'manifest:',
    'format:',
    'quiet',
    'refresh-calendar',
    'apply',
    'plan',
]);

$dryRun = array_key_exists('dry-run', $opts);
$quiet  = array_key_exists('quiet', $opts);
$refreshCalendar = array_key_exists('refresh-calendar', $opts);
$apply = array_key_exists('apply', $opts);
$plan = array_key_exists('plan', $opts);

$schedulePath = $opts['schedule'] ?? $DEFAULT_SCHEDULE_PATH;
$manifestPath = $opts['manifest'] ?? $DEFAULT_MANIFEST_PATH;
$format       = $opts['format']   ?? 'text';

if (!in_array($format, ['text', 'json'], true)) {
    fwrite(STDERR, "ERROR: --format must be 'text' or 'json'\n");
    exit(64);
}

// -----------------------------------------------------------------------------
// Dependency construction
// -----------------------------------------------------------------------------

// -------------------------------------------------------------------------
// Export FPP environment via web context (authoritative, always fresh)
// -------------------------------------------------------------------------


$envPath = '/home/fpp/media/config/calendar-scheduler/runtime/fpp-env.json';

$readEnvEpoch = static function (string $path): int {
    if (!file_exists($path)) {
        return 0;
    }
    $data = json_decode(file_get_contents($path), true);
    if (!is_array($data)) {
        return 0;
    }
    $epoch = $data['generatedAtEpoch'] ?? 0;
    return is_int($epoch) ? $epoch : (int) $epoch;
};

$beforeEpoch = $readEnvEpoch($envPath);

$envUrl = getenv('GCS_FPP_ENV_URL');
if ($envUrl === false || trim($envUrl) === '') {
    $envUrl = 'http://127.0.0.1/plugin.php?plugin=GoogleCalendarScheduler&page=fpp-env-export.php&nopage=1';
}

$cmd = 'curl --silent --show-error --fail --max-time 5 '
     . '--output /dev/null '
     . escapeshellarg($envUrl);
exec($cmd, $out, $rc);

if ($rc !== 0) {
    throw new RuntimeException('Failed to invoke FPP environment exporter via web');
}

if (!file_exists($envPath)) {
    throw new RuntimeException('fpp-env.json was not written by web exporter');
}

$env = json_decode(file_get_contents($envPath), true);
if (!is_array($env)) {
    throw new RuntimeException('fpp-env.json is not valid JSON');
}

if (($env['ok'] ?? false) !== true) {
    $errors = $env['errors'] ?? [];
    $msg = is_array($errors) ? implode('; ', $errors) : (string) $errors;
    throw new RuntimeException('fpp-env.json export failed: ' . $msg);
}

$afterEpoch = $env['generatedAtEpoch'] ?? 0;
$afterEpoch = is_int($afterEpoch) ? $afterEpoch : (int) $afterEpoch;

if ($afterEpoch <= $beforeEpoch) {
    throw new RuntimeException('fpp-env.json was not refreshed (generatedAtEpoch did not advance)');
}

try {
    // -------------------------------------------------------------------------
    // Refresh calendar snapshot if requested
    // -------------------------------------------------------------------------
    if ($refreshCalendar) {
        // Use the correct constructor for CalendarTranslator (with IcsParser and snapshot path)
        $icsParser = new IcsParser();
        $translator = new CalendarTranslator($icsParser, $DEFAULT_CALENDAR_SNAPSHOT_PATH);
        $snapshot = new CalendarSnapshot($translator);

        try {
            $events = $snapshot->refreshFromIcs();
            $snapshot->write($events);
            fwrite(STDERR, "[INFO] Calendar snapshot refreshed\n");
        } catch (\Throwable $e) {
            throw new RuntimeException('Failed to refresh calendar snapshot: ' . $e->getMessage());
        }
    }

    // -------------------------------------------------------------------------
    // Normalization context
    // -------------------------------------------------------------------------


    $tzName = $env['timezone']
        ?? $env['rawLocale']['timezone']
        ?? 'UTC';

    $context = new NormalizationContext(
        new DateTimeZone($tzName),
        new FPPSemantics(),
        new HolidayResolver($env['rawLocale']['holidays'])
    );

    $normalizer = new IntentNormalizer();

    // -------------------------------------------------------------------------
    // Load existing manifest (if any)
    // -------------------------------------------------------------------------

    $currentManifest = ['events' => []];
    if (file_exists($manifestPath)) {
        $currentManifest = json_decode(
            file_get_contents($manifestPath),
            true,
            512,
            JSON_THROW_ON_ERROR
        );
    }


    // -------------------------------------------------------------------------
    // Calendar → adapter → Intent (desired state)
    // -------------------------------------------------------------------------

    $calendarAdapter = new GoogleCalendarAdapter();

    $calendarIntents = [];
    $calendarAuthority = [];

    $calendarEvents = $calendarAdapter->loadManifestEvents(
        $context,
        $DEFAULT_CALENDAR_SNAPSHOT_PATH
    );

    // === Calendar Adapter Events ===
    if (getenv('GCS_DEBUG_INTENTS') === '1') {
        fwrite(STDERR, "=== Calendar Adapter Events ===\n");
        foreach ($calendarEvents as $event) {
            $identityHash = $event['identityHash'] ?? '';
            $target = $event['target'] ?? '';
            $start = $event['start'] ?? '';
            $end = $event['end'] ?? '';
            $days = $event['days'] ?? '';
            $enabled = $event['enabled'] ?? '';
            fwrite(
                STDERR,
                sprintf(
                    "identityHash=%s target=%s start=%s end=%s days=%s enabled=%s\n",
                    $identityHash,
                    $target,
                    $start,
                    $end,
                    is_array($days) ? implode(',', $days) : $days,
                    var_export($enabled, true)
                )
            );
        }
    }

    foreach ($calendarEvents as $event) {
        $intent = $normalizer->fromManifestEvent($event, $context);
        $hash = $intent->identityHash;
        $calendarIntents[$hash] = $intent;
        $calendarAuthority[$hash] = (int)($event['updatedAtEpoch'] ?? 0);
    }

    // -------------------------------------------------------------------------
    // FPP → adapter → Intent (current state contributor)
    // -------------------------------------------------------------------------
    
    $fppAdapter = new FppScheduleAdapter();

    $fppIntents = [];
    $fppAuthority = [];

    $fppEvents = $fppAdapter->loadManifestEvents(
        $context,
        $schedulePath
    );

    // === FPP Adapter Events ===
    if (getenv('GCS_DEBUG_INTENTS') === '1') {
        fwrite(STDERR, "=== FPP Adapter Events ===\n");
        foreach ($fppEvents as $event) {
            $identityHash = $event['identityHash'] ?? '';
            $target = $event['target'] ?? '';
            $start = $event['start'] ?? '';
            $end = $event['end'] ?? '';
            $days = $event['days'] ?? '';
            $enabled = $event['enabled'] ?? '';
            fwrite(
                STDERR,
                sprintf(
                    "identityHash=%s target=%s start=%s end=%s days=%s enabled=%s\n",
                    $identityHash,
                    $target,
                    $start,
                    $end,
                    is_array($days) ? implode(',', $days) : $days,
                    var_export($enabled, true)
                )
            );
        }
    }

    foreach ($fppEvents as $event) {
        $intent = $normalizer->fromManifestEvent($event, $context);
        $hash = $intent->identityHash;
        $fppIntents[$hash] = $intent;
        $fppAuthority[$hash] = (int)($event['updatedAtEpoch'] ?? 0);
    }

    // -------------------------------------------------------------------------
    // Build Next Manifests
    // -------------------------------------------------------------------------

    $planner = new ManifestPlanner();
    $calendarManifest = $planner->buildManifestFromIntents($calendarIntents);
    $fppManifest = $planner->buildManifestFromIntents($fppIntents);

    // -------------------------------------------------------------------------
    // Diff (manifest → manifest)
    // -------------------------------------------------------------------------

    $diff = new Diff();
    $diffPlan = $diff->diff(
        $calendarManifest,
        $currentManifest
    );

    // -------------------------------------------------------------------------
    // Reconcile (always runs; pure planning)
    // -------------------------------------------------------------------------

    $calendarSnapshotEpoch = filemtime($DEFAULT_CALENDAR_SNAPSHOT_PATH);
    $calendarSnapshotEpoch = is_int($calendarSnapshotEpoch) && $calendarSnapshotEpoch > 0 ? $calendarSnapshotEpoch : time();

    $fppSnapshotEpoch = filemtime($schedulePath);
    $fppSnapshotEpoch = is_int($fppSnapshotEpoch) && $fppSnapshotEpoch > 0 ? $fppSnapshotEpoch : time();

    $reconciler = new Reconciler();
    $result = $reconciler->reconcile(
        $calendarManifest,
        $fppManifest,
        $currentManifest,
        $calendarAuthority,
        $fppAuthority,
        $calendarSnapshotEpoch,
        $fppSnapshotEpoch
    );

    if ($plan) {
        foreach ($result->actions() as $action) {
            printf(
                "[%s → %s] %-6s identity=%s reason=\"%s\"\n",
                $action->authority,
                $action->target,
                strtoupper($action->type),
                $action->identityHash,
                $action->reason
            );
        }

        if ($result->actionCount() === 0) {
            echo "No reconciliation actions required.\n";
        }

        exit(0);
    }

    // -------------------------------------------------------------------------
    // Write manifest
    // -------------------------------------------------------------------------

    // Removed: manifest mutation during planning to enforce Apply boundary

} catch (\InvalidArgumentException $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(1);

} catch (\RuntimeException $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(1);

} catch (Throwable $e) {

    fwrite(STDERR, "ERROR: {$e->getMessage()}\n");
    exit(2);
}

// -----------------------------------------------------------------------------
// Output
// -----------------------------------------------------------------------------

 $countCreate = $diffPlan->createCount();
 $countUpdate = $diffPlan->updateCount();
 $countDelete = $diffPlan->deleteCount();

 $countCreateFpp = 0;
 $countUpdateFpp = 0;
 $countDeleteFpp = 0;

 $countCreateCalendar = 0;
 $countUpdateCalendar = 0;
 $countDeleteCalendar = 0;

 foreach ($result->actions() as $action) {
     // ignore noop/block for counts
     if ($action->type === ReconciliationAction::TYPE_NOOP || $action->type === ReconciliationAction::TYPE_BLOCK) {
         continue;
     }

     if ($action->target === ReconciliationAction::TARGET_FPP) {
         if ($action->type === ReconciliationAction::TYPE_CREATE) $countCreateFpp++;
         elseif ($action->type === ReconciliationAction::TYPE_UPDATE) $countUpdateFpp++;
         elseif ($action->type === ReconciliationAction::TYPE_DELETE) $countDeleteFpp++;
         continue;
     }

     if ($action->target === ReconciliationAction::TARGET_CALENDAR) {
         if ($action->type === ReconciliationAction::TYPE_CREATE) $countCreateCalendar++;
         elseif ($action->type === ReconciliationAction::TYPE_UPDATE) $countUpdateCalendar++;
         elseif ($action->type === ReconciliationAction::TYPE_DELETE) $countDeleteCalendar++;
         continue;
     }
 }

if ($apply) {
    $options = new ApplyOptions(
        ApplyMode::APPLY,
        WritableTargets::fppOnly(),
        true // fail if calendar actions are blocked
    );

    $applier = new ApplyRunner(
        new ManifestWriter($manifestPath),
        new FppScheduleAdapter()
    );

    $applier->apply($result, $options);
}

if ($format === 'json') {
    if ($dryRun) {
        echo json_encode([
            'noop'    => $countCreateFpp === 0 && $countUpdateFpp === 0 && $countDeleteFpp === 0 &&
                         $countCreateCalendar === 0 && $countUpdateCalendar === 0 && $countDeleteCalendar === 0,
            'fpp' => [
                'created' => $countCreateFpp,
                'updated' => $countUpdateFpp,
                'deleted' => $countDeleteFpp,
            ],
            'calendar' => [
                'created' => $countCreateCalendar,
                'updated' => $countUpdateCalendar,
                'deleted' => $countDeleteCalendar,
            ],
            'dry_run' => $dryRun,
        ], JSON_PRETTY_PRINT) . "\n";
        exit(0);
    }

    echo json_encode([
        'noop'    => $countCreate === 0 && $countUpdate === 0 && $countDelete === 0,
        'created' => $countCreate,
        'updated' => $countUpdate,
        'deleted' => $countDelete,
        'dry_run' => $dryRun,
    ], JSON_PRETTY_PRINT) . "\n";
    exit(0);
}

// text output
if ($quiet) {
    exit(0);
}

if ($dryRun) {
    echo "Dry run complete.\n";
    echo "FPP would create: {$countCreateFpp}\n";
    echo "FPP would update: {$countUpdateFpp}\n";
    echo "FPP would delete: {$countDeleteFpp}\n";
    echo "Calendar would create: {$countCreateCalendar}\n";
    echo "Calendar would update: {$countUpdateCalendar}\n";
    echo "Calendar would delete: {$countDeleteCalendar}\n";
    exit(0);
}

if ($countCreate === 0 && $countUpdate === 0 && $countDelete === 0) {
    echo "Scheduler run complete.\n";
    echo "No changes required.\n";
    exit(0);
}

echo "Scheduler run complete.\n";
echo "Created: {$countCreate}\n";
echo "Updated: {$countUpdate}\n";
echo "Deleted: {$countDelete}\n";
exit(0);
